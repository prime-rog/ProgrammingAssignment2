## Put comments here that give an overall description of what your
## functions do

## Write a short comment describing this function

# Matrix inversion is usually  costly computation and there may be some
#benifit to caching the inverse of a matrix rather than compute it repeatdly.
#Below are a pair of function that are used to create a special object that
#stores a matrix and caches its inverse

# This function creates a special "matrix" object that can cache its inverse

makeCacheMatrix <- function(x = matrix()) {
        inv <- NULL
        set <- function(y){
                x<<- y
                inv <<- NULL
        }
        get <- function() x
        setInverse <- function(inverse) inv <<- inverse
        getInverse <- function() inv
        list(set =set , 
             get = get, 
             setInverse = setInverse,
             getInverse = getInverse)
        
}


## Write a short comment describing this function
# This function computes the inverse of the special "matrix" created by
#makeCacheMatrix above , If the inverse has already been calculated (and the
#matrix has not changed), then it should retrieve the inverse from the cache.


cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
        inv <- x$getInverse()
        if(!is.null(inv))
        {
                paste("getting cached data")
                return (inv)
        }
        mat <- x$get()
        inv<- solve(mat , ...)
        x$setInverse(inv)
        inv
}
